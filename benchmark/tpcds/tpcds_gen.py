#!/usr/bin/env python3
"""
Generate TPC-DS data (and optional answers) using DuckDB's tpcds extension.

Always fetches queries from DuckDB before generating data.

Usage:
  uvx --from duckdb python benchmark/tpcds/tpcds_gen.py --scale 0.1 --answers-dir benchmark/tpcds/answers
"""

import argparse
import json
import os
import sys
from pathlib import Path
from typing import Dict, List, Optional, Tuple

import duckdb


DEFAULT_QUERIES = 99


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Generate TPC-DS data and optional answers with DuckDB")
    parser.add_argument("--scale", type=float, default=0.1, help="Scale factor (default: 0.1)")
    parser.add_argument("--data-dir", type=Path, default=Path("benchmark/tpcds/data"), help="Output root for tables")
    parser.add_argument("--answers-dir", type=Path, help="Output root for answer Parquet files (optional)")
    parser.add_argument("--queries-dir", type=Path, default=Path("benchmark/tpcds/queries"), help="Directory containing qNN.sql files")
    parser.add_argument("--manifest", type=Optional[Path], default=None, help="Path to write manifest.json")
    parser.add_argument("--duckdb", type=Path, help="Optional path to DuckDB executable")
    parser.add_argument("--seed", type=int, help="Optional seed if DuckDB supports deterministic dsdgen")
    parser.add_argument("--overwrite", action="store_true", help="Allow overwriting existing Parquet/manifest files")
    return parser.parse_args()


def fetch_queries_from_duckdb(conn: duckdb.DuckDBPyConnection) -> List[Tuple[int, str]]:
    """Fetch the 99 TPC-DS queries from DuckDB's tpcds extension."""
    rows = conn.execute("SELECT query_nr, query FROM tpcds_queries() ORDER BY query_nr").fetchall()
    return [(int(q), sql) for q, sql in rows]


def write_queries(queries: List[Tuple[int, str]], out_dir: Path, overwrite: bool):
    """Write query SQL files to the specified directory."""
    out_dir.mkdir(parents=True, exist_ok=True)
    for qnum, sql in queries:
        fname = out_dir / f"q{qnum}.sql"
        if fname.exists() and not overwrite:
            print(f"Query exists, skipping (use --overwrite to regenerate): {fname}")
            continue
        fname.write_text(sql)
        print(f"Wrote {fname}")


def table_list(conn: duckdb.DuckDBPyConnection) -> List[str]:
    # Capture table names generated by dsdgen in the main schema.
    rows = conn.execute(
        "SELECT table_name FROM information_schema.tables WHERE table_schema = 'main' ORDER BY table_name"
    ).fetchall()
    return [r[0] for r in rows]


def ensure_dir(path: Path):
    path.mkdir(parents=True, exist_ok=True)


def copy_table(conn: duckdb.DuckDBPyConnection, table: str, dest: Path):
    dest.parent.mkdir(parents=True, exist_ok=True)
    # ORDER BY ALL enforces deterministic row order in Parquet output.
    conn.execute(f"COPY (SELECT * FROM {table} ORDER BY ALL) TO '{dest}' (FORMAT PARQUET)")


def load_query(path: Path) -> str:
    # DuckDB COPY does not accept a trailing semicolon inside the subquery.
    return path.read_text().rstrip().removesuffix(";").strip()


def export_answers(conn: duckdb.DuckDBPyConnection, queries_dir: Path, answers_root: Path, scale: float, overwrite: bool) -> Dict[str, str]:
    answers: Dict[str, str] = {}
    output_dir = answers_root / f"sf{scale}"
    ensure_dir(output_dir)

    for qnum in range(1, DEFAULT_QUERIES + 1):
        qfile = queries_dir / f"q{qnum}.sql"
        if not qfile.exists():
            print(f"Warning: missing query file {qfile}, skipping")
            continue

        query_sql = load_query(qfile)
        dest = output_dir / f"q{qnum}.parquet"
        if dest.exists() and not overwrite:
            print(f"Answer exists, skipping (use --overwrite to regenerate): {dest}")
            answers[f"q{qnum}"] = str(dest)
            continue

        print(f"Running query q{qnum} -> {dest}")
        conn.execute(f"COPY ({query_sql}) TO '{dest}' (FORMAT PARQUET)")
        answers[f"q{qnum}"] = str(dest)

    return answers


def write_manifest(manifest_path: Path, tables: Dict[str, str], queries_dir: Path, answers: Optional[Dict[str, str]]):
    manifest = {
        "name": "TPC-DS",
        "tables": tables,
        "queries": [],
    }

    for qnum in range(1, DEFAULT_QUERIES + 1):
        qfile = queries_dir / f"q{qnum}.sql"
        if qfile.exists():
            manifest["queries"].append(str(qfile))

    if answers:
        manifest["answers"] = answers

    manifest_path.parent.mkdir(parents=True, exist_ok=True)
    with manifest_path.open("w") as f:
        json.dump(manifest, f, indent=2)
        f.write("\n")


def main():
    args = parse_args()

    data_dir = args.data_dir / f"sf{args.scale}"
    answers_dir = args.answers_dir

    if args.duckdb:
        # If a DuckDB executable is specified, set DUCKDB_EXECUTABLE so duckdb Python uses it.
        os.environ["DUCKDB_EXECUTABLE"] = str(args.duckdb)

    conn = duckdb.connect(database=":memory:")
    try:
        print("Installing/loading DuckDB tpcds extension...")
        conn.execute("INSTALL tpcds")
        conn.execute("LOAD tpcds")

        # Fetch queries from DuckDB
        print(f"Fetching TPC-DS queries from DuckDB...")
        queries = fetch_queries_from_duckdb(conn)
        if len(queries) != DEFAULT_QUERIES:
            print(f"Warning: expected {DEFAULT_QUERIES} queries, got {len(queries)}")
        write_queries(queries, args.queries_dir, args.overwrite)
        print(f"Query fetch complete. Wrote {len(queries)} queries to {args.queries_dir}")

        if args.seed is not None:
            try:
                conn.execute(f"SET generator_seed={args.seed}")
                print(f"Set generator_seed={args.seed}")
            except Exception as e:
                print(f"Warning: failed to set seed: {e}")

        print(f"Running dsdgen at scale {args.scale} ...")
        conn.execute(f"CALL dsdgen(sf={args.scale})")

        tables = table_list(conn)
        table_paths: Dict[str, str] = {}
        ensure_dir(data_dir)
        for table in tables:
            dest = data_dir / f"{table}.parquet"
            if dest.exists() and not args.overwrite:
                print(f"Table exists, skipping (use --overwrite to regenerate): {dest}")
            else:
                print(f"Exporting table {table} -> {dest}")
                copy_table(conn, table, dest)
            table_paths[table] = str(dest)

        answers = None
        if answers_dir:
            answers = export_answers(conn, args.queries_dir, answers_dir, args.scale, args.overwrite)

        if args.manifest:
            write_manifest(args.manifest, table_paths, args.queries_dir, answers)
            print(f"Wrote manifest to {args.manifest}")

    except Exception as e:
        print(f"Error during generation: {e}")
        sys.exit(1)
    finally:
        conn.close()


if __name__ == "__main__":
    main()
